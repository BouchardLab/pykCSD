# -*- coding: utf-8 -*-
import numpy as np
import basis_functions as bf
from scipy import integrate
from numpy import pi

"""
This module contains routines for calculating potentials in 1D, 2D, 3D case.
This consists of integrands and integrals.
"""


def int_pot_1D(src, arg, curr_pos ,h, R, sigma, src_type):
    """
    Returns contribution of a single source as a function of distance
    """
    y = (((arg - curr_pos)**2 + h**2)**0.5 - abs(arg - curr_pos)) #h czy R
    y *= 1./(2 * sigma)
    #y *= (np.abs(x-xp)<2*h) #???

    if src_type == "gaussian":
        # for this formula look at formula (8) from Pettersen et al., 2006
        y *= bf.gauss_rescale_1D(src, curr_pos, R)
    if src_type == "step":
        y *= bf.step_rescale_1D(src, curr_pox, R)
    if src_type == 'gauss_lim':
        y *= bf.gauss_rescale_lim_1D(src, curr_pos, R)

    return y


def b_pot_quad(src, arg, R, h, sigma, src_type):
    """
    Returns potential as a function of distance from the source.
    """
    resolution = 51
    x = np.linspace(src - 3*R, src + 3*R, resolution)
    potx = np.array([int_pot_1D(src, arg, current_pos, h, R, sigma, src_type)
                    for current_pos in x])

    pot = np.trapz(potx, x)
    #print -R, R
    #print x, R, h, sigma, src_type
    """pot, err = integrate.quad(int_pot_1D,
                              -R,  R,
                              args=(x, R, h, sigma, src_type),
                              epsrel=1e0, epsabs=1e0)"""


    return pot


def int_pot_2D(xp, yp, x, R, h, src_type):
    """INPUT
    xp,yp    - coordinates of some point laying in the support of a
               basis element centered at (0,0)
    x        - x - coordinate of a point (x,0) at which we calculate the
             - potential
    R        - radius of the basis element
    h
    src_type - type of basis function in the source space
               (step/gauss/gauss_lim)
    OUTPUT
    int_pot - contribution of a point xp,yp, belonging to a basis source
            - support centered at (0,0) to the potential measured at (x,0),
            - integrated over xp,yp gives the potential generated by a
            - basis source element centered at (0,0) at point (x,0)
    """
    y = ((x-xp)**2 + yp**2)**(0.5)
    if y < 0.00001:
        y = 0.00001
    y = np.arcsinh(h/y)
    if src_type == 'step':
        y *= bf.step_rescale_2D(xp, yp, R)
    elif src_type == 'gaussian':
        y *= bf.gauss_rescale_2D(xp, yp, [0, 0], R)
    elif src_type == 'gauss_lim':
        y *= bf.gauss_rescale_2D_lim(xp, yp, [0, 0], R)
    return y


def b_pot_2d_cont(x, R, h, sigma, src_type):
    """
    Returns the value of the potential at point (x,0) generated
    by a basis source located at (0,0)
    """
    pot, err = integrate.dblquad(int_pot_2D, -R, R,
                                 lambda x: -R, lambda x: R,
                                 args=(x, R, h, src_type),
                                 epsrel=1e0, epsabs=1e0)
    pot *= 1./(2.0*pi*sigma)
    return pot


def int_pot_3D(xp, yp, zp, x, R, h, src_type):
    """INPUT
    xp,yp,zp    - coordinates of some point laying in the support of a
                basis element centered at (0,0,0)
    x        - coordinates of a point (x,0,0) at which we calculate the
                potential
    R        - radius of the basis element
    h
    src_type - type of basis function in the source space
                    (step/gauss/gauss_lim)
    OUTPUT
            contribution of a point xp,yp,zp belonging to a basis source
            support centered at (0,0,0) to the potential measured at (x,0,0)
            integrated over xp, yp, zp gives the potential generated by a
            basis source element centered at (0,0,0) at point (x,0,0)
    """
    y = ((x-xp)**2 + yp**2 + zp**2)**0.5
    if y < 0.00001:
        y = 0.00001
    y = 1.0/y
    if src_type == 'step':
        y *= bf.step_rescale_3D(xp, yp, zp, R)
    elif src_type == 'gaussian':
        y *= bf.gauss_rescale_3D(xp, yp, zp, [0, 0, 0], R)
    elif src_type == 'gauss_lim':
        y *= bf.gauss_rescale_lim_3D(xp, yp, zp, [0, 0, 0], R)
    return y


def b_pot_3d_cont(x, R, h, sigma, src_type):
    """
    Returns the value of the potential at point (x,y,0) generated
    by a basis source located at (0,0,0)
    """
    pot, err = integrate.tplquad(int_pot_3D, -R, R,
                                 lambda x: -R, lambda x: R,
                                 lambda x, y: -R, lambda x, y: R,
                                 args=(x, R, h, src_type))
    pot *= 1./(4.0*pi*sigma)
    return pot