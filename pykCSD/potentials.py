# -*- coding: utf-8 -*-
from __future__ import division

import numpy as np
import basis_functions as bf
from scipy import integrate
from numpy import pi, uint16

from skmonaco import mcquad

"""
This module contains routines for calculating potentials in 1D, 2D, 3D case.
This consists of integrands and integrals.
"""


def int_pot_1D(src, arg, curr_pos, h, R, sigma, basis_func):
    """
    Returns contribution of a single source as a function of distance
    """
    y = (((arg - curr_pos)**2 + h**2)**0.5 - abs(arg - curr_pos))  # h czy R
    y *= 1./(2 * sigma)
    # y *= (np.abs(x-xp)<2*h) #???

    # for this formula look at formula (8) from Pettersen et al., 2006
    y *= basis_func(src, curr_pos, R)

    return y


def b_pot_quad(src, arg, R, h, sigma, basis_func=bf.gauss_rescale_1D):
    """
    Returns potential as a function of distance from the source.
    """
    resolution = 51
    x = np.linspace(src - 3*R, src + 3*R, resolution)
    potx = np.array([int_pot_1D(src, arg, current_pos, h, R, sigma, basis_func)
                    for current_pos in x])

    pot = np.trapz(potx, x)
    # print -R, R
    # print x, R, h, sigma, src_type
    """pot, err = integrate.quad(int_pot_1D,
                              -R,  R,
                              args=(x, R, h, sigma, src_type),
                              epsrel=1e0, epsabs=1e0)"""
    return pot


def int_pot_2D(xp, yp, x, R, h, basis_func=bf.gauss_rescale_lim_2D):
    """INPUT
    xp,yp    - coordinates of some point laying in the support of a
               basis element centered at (0,0)
    x        - x - coordinate of a point (x,0) at which we calculate the
             - potential
    R        - radius of the basis element
    h
    basis_func - type of basis function in the source space
                (step_rescale_2D/gauss_rescale_2D/gauss_rescale_lim_2D)
    OUTPUT
    int_pot - contribution of a point xp,yp, belonging to a basis source
            - support centered at (0,0) to the potential measured at (x,0),
            - integrated over xp,yp gives the potential generated by a
            - basis source element centered at (0,0) at point (x,0)
    """
    y = ((x-xp)**2 + yp**2)**(0.5)
    if y < 0.00001:
        y = 0.00001
    y = np.arcsinh(h/y)

    y *= basis_func(xp, yp, [0, 0], R)
    return y


def b_pot_2d_cont(x, R, h, sigma, src_type):
    """
    Returns the value of the potential at point (x,0) generated
    by a basis source located at (0,0)
    """
    pot, err = integrate.dblquad(int_pot_2D, -R, R,
                                 lambda x: -R, lambda x: R,
                                 args=(x, R, h, src_type),
                                 epsrel=1e-2, epsabs=0)
    pot *= 1./(2.0*pi*sigma)
    return pot


def int_pot_3D(xp, yp, zp, x, R, h, basis_func):
    """INPUT
    xp,yp,zp    - coordinates of some point laying in the support of a
                basis element centered at (0,0,0)
    x        - coordinates of a point (x,0,0) at which we calculate the
                potential
    R        - radius of the basis element
    h
    src_type - type of basis function in the source space
                    (step/gauss/gauss_lim)
    OUTPUT
            contribution of a point xp,yp,zp belonging to a basis source
            support centered at (0,0,0) to the potential measured at (x,0,0)
            integrated over xp, yp, zp gives the potential generated by a
            basis source element centered at (0,0,0) at point (x,0,0)
    """
    y = ((x-xp)**2 + yp**2 + zp**2)**0.5
    if y < 0.00001:
        y = 0.00001
    y = 1.0/y

    y *= basis_func(xp, yp, zp, [0, 0, 0], R)
    return y


def b_pot_3d_cont(x, R, h, sigma, basis_func=bf.gauss_rescale_3D):
    """
    Returns the value of the potential at point (x,y,0) generated
    by a basis source located at (0,0,0)
    """
    pot, err = integrate.tplquad(int_pot_3D, -R, R,
                                 lambda x: -R, lambda x: R,
                                 lambda x, y: -R, lambda x, y: R,
                                 args=(x, R, h, basis_func))
    pot *= 1./(4.0*pi*sigma)
    return pot


def int_pot_3D_mc(xyz, x, R, h, basis_func):
    """
    The same as int_pot_3D, just different input: x,y,z <-- xyz (tuple)
    """
    xp, yp, zp = xyz
    return int_pot_3D(xp, yp, zp, x, R, h, basis_func)


def b_pot_3d_mc(x, R, h, sigma, basis_func=bf.gauss_rescale_3D):
    """
    Calculate potential using Monte Carlo integration
    """
    pot, err = mcquad(int_pot_3D_mc, npoints=1e5,
                      xl=[-R, -R, -R], xu=[R, R, R],
                      nprocs=4, args=(x, R, h, basis_func))
    pot *= 1./(4.0*pi*sigma)
    return pot


def probe_dist_table_points(R, dist_max, dist_table_density):
    """
    """
    dense_step = 3
    denser_step = 1
    sparse_step = 9
    border1 = 0.9 * R/dist_max * dist_table_density
    border2 = 1.3 * R/dist_max * dist_table_density

    xs = np.arange(0,  border1, dense_step)
    xs = np.append(xs, border1)
    zz = np.arange((border1 + denser_step), border2, dense_step)

    xs = np.concatenate((xs, zz))
    xs = np.append(xs, [border2, (border2 + denser_step)])
    xs = np.concatenate((xs, np.arange((border2 + denser_step + sparse_step/2),
                                       dist_table_density, sparse_step)))
    xs = np.append(xs, dist_table_density + 1)

    xs = np.unique(np.array(xs))

    return xs


# TODO generalize generated potential to 1,2,3 dimensions
def generated_potential(self, x_src, dist_max, dist_table):
    """
    Returns potential at a specified distance in distance_table
    """
    dt_len = len(dist_table)
    norms = np.sqrt((self.space_X - x_src)**2)
    ind = np.maximum(0, np.minimum(uint16(np.round(dt_len * norms/dist_max)),
                                   dt_len - 1))

    pot = dist_table[ind]
    return pot


def generated_potential2D(self, x_src, y_src,  dist_max, dt_len):
    """
    """
    norms = np.sqrt((self.space_X - x_src)**2 + (self.space_Y - y_src)**2)
    ind = np.maximum(0, np.minimum(uint16(np.round(dt_len * norms/dist_max)),
                                   dt_len-1))

    pot = self.dist_table[ind]
    return pot